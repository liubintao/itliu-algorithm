## 求斐波那契数列矩阵乘法的方法
1）斐波那契数列的线性求解（O(N)）的方式非常好理解
 
2）同时利用线性代数，也可以改写出另一种表示

 | F(N) , F(N-1) | = | F(2), F(1) |  *  某个二阶矩阵的N-2次方
 例：|F(N),F(N-1)| = |F(2),F(1)| * |1110|^n-2

3）求出这个二阶矩阵，进而最快求出这个二阶矩阵的N-2次方

如何最快求出二阶矩阵的N次方？我们先来看一个问题 10^75如何算的更快
75的二进制是64+8+2+1=1001011
10^75 = 10^64 * 10^8 * 10^2 * 10^1  那怎么依次求呢？
最终的结果，记为res，初始值res = 1; 搞个临时变量t=10^1,t每次都和自己相乘

过程：
75的二进制是64+8+2+1=1001011，求解过程低位到高位
开始不乘的时候，最低位是1，表示要把t乘到res里去 res = 1 * 10^1，乘完之后t与自己相乘变成10^1 * 10^1 = 10^2
来到下一个位置也是1，把t^2乘到res里去 res = 1 * 10^1 * 10^2，乘完之后t与自己相乘变成10^2 * 10^2 = 10^4
来到下一个位置是0，不把t^4乘到res里去，然后t与自己相乘变成10^4 * 10^4 = 10^8
来到下一个位置也是1，把t^8乘到res里去 res = 1 * 10^1 * 10^2 * 10^8，乘完之后t与自己相乘变成10^8 * 10^8 = 10^16
来到下一个位置是0，不把t^16乘到res里去，然后t与自己相乘变成10^16 * 10^16 = 10^32
来到下一个位置是0，不把t^32乘到res里去，然后t与自己相乘变成10^32 * 10^32 = 10^64
来到下一个位置是1，把t^64乘到res里去 res = 1 * 10^1 * 10^2 * 10^8 * 10^64，搞定！
我们用75的二进制形式规定了哪些东西进res，哪些东西不进res

10^75 每次 * 10 相当于乘以75次，而按照上面的算法只乘了6次，75的二进制形式有N位，上面的方法就乘以N-1次，10^75这么乘是最省时间的
t和自己玩的时候不去鸟别人，但是它变成的数要不要进res由75的二进制决定，10^75这么乘最快  |a|^75同理

## 类似斐波那契数列的递归优化
如果某个递归，除了初始项之外，具有如下的形式

F(N) = C1 * F(N) + C2 * F(N-1) + … + Ck * F(N-k) ( C1…Ck 和k都是常数)

并且这个递归的表达式是严格的、不随条件转移的

那么都存在类似斐波那契数列的优化，时间复杂度都能优化成O(logN)

## 矩阵理解
矩阵加法
https://jingyan.baidu.com/article/6525d4b186fd4cac7c2e946f.html
矩阵乘法
https://jingyan.baidu.com/article/4ae03de3d2b8c13eff9e6b1e.html
二阶矩阵乘法
https://zhidao.baidu.com/question/564217046079515004.html
