## 单调栈是什么
一种特别设计的栈结构，为了解决如下的问题：

给定一个可能含有重复值的数组arr，i位置的数一定存在如下两个信息
1）arr[i]的左侧离i最近并且小于(或者大于)arr[i]的数在哪？
2）arr[i]的右侧离i最近并且小于(或者大于)arr[i]的数在哪？
如果想得到arr中所有位置的两个信息，怎么能让得到信息的过程尽量快。

那么到底怎么设计呢？

## 单调栈的结构

 大              *     *
 |               *     *
 |               *     *
 |               *  a  *
 |               *  b  * 
 小              * * * *
  
 假设在栈中，b先入栈，a后入栈，会不会存在b和a之间有其他值得情况？
 1.会不会存在<b的值？
 假如存在<b的值，那这个值一定会让b出栈，轮不到a来和b做邻居。
 2.会不会存在b<?<a的值？
 假如存在b<?<a的值，那a一定会让这个值出栈，也轮不到a来和b做邻居。
 3.会不会存在>a的值？
 假如存在>a的值，那么a一定会让这个值出栈，然后a和b做邻居。
 
 综上所述：a和b之间要么没值，要么存在>a的值
 以上是不存在等值的情况？如果存在等值情况下：将栈中存储值变成存储List
 
 存在等值情况下，栈中相邻的两组数为什么可以挨着？
 要么这两个数挨着，要么这两个数中间的值都比这两个数大
 
 ### 应用
 累加和预处理技巧
 
 题目：
 给定一个只包含正数的数组arr，arr中任何一个子数组sub，
 一定都可以算出(sub累加和 )* (sub中的最小值)是什么，
 那么所有子数组中，这个值最大是多少？

sub累加和 和 范围建立了单调性

求arr[L..R]的累加和就等于 0..R的累加和sum[R]-0..L-1的累加和sum[L-1]    这可能是最常见的预处理技巧
我们要怎么去求一个子数组累加和 * 子数组最小值   每个子数组都会有这个值，那么哪个子数组这个值是最大的呢

对于数组 arr[3,4,5,6,3,2,7]
我先盯着0位置的3，我一定要让找到的子数组包含这个3，而且我要让这个3在这个子数组中是最小值，我能找到哪个范围的子数组?
找到的范围是[3,4,5,6,3]，这时没有办法再往右走了，再走就不是以3做最小值了。这时找到了以3做最小值最大的范围，找到的指标是最小值3*子数组累加和
接着来求1位置的4做最小值的情况下子数组能扩多远，结果是[4,5,6]，这时就可以求出以4做最小值的指标

范围越大，累加和越大，如果每个位置都求一个答案，则整体答案必在其中
回到题意：(sub累加和 )* (sub中的最小值)   
也就是说：我们可以确定最小值，求出以这个最小值对应的子数组累加和即可，怎么求呢？
左边离你最近的比你小的数在哪是你扩不到的位置，右边离你最近的比你小的数在哪是你扩不到的位置，中间完全都可以扩到，左右两个位置调单调栈获得，累加和又是O(1)的操作拿到的，岂不美哉
总结：求当前数左边比你小的值，右边比你小的值，这俩数中间的数组成的子数组就是以当前数作为最小值的最大范围子数组，每个数都来一遍这个操作，题目中的最大值必在其中