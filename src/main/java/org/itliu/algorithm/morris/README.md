## Morris遍历
一种遍历二叉树的方式，并且时间复杂度O(N)，额外空间复杂度O(1)
通过利用原树中大量空闲指针的方式，达到节省空间的目的

## Morris遍历细节
假设来到当前节点cur，开始时cur来到头节点位置
1）如果cur没有左孩子，cur向右移动(cur = cur.right)
2）如果cur有左孩子，找到左子树上最右的节点mostRight：
	a.如果mostRight的右指针指向空，让其指向cur，
	然后cur向左移动(cur = cur.left)
	b.如果mostRight的右指针指向cur，让其指向null，
	然后cur向右移动(cur = cur.right)
3）cur为空时遍历停止

## Morris遍历实质
建立一种机制：
对于没有左子树的节点只到达一次，
对于有左子树的节点会到达两次
morris遍历时间复杂度依然是O(N)

## 重要
Morris时间复杂度O(N),空间复杂度可以从O(H)优化成O(1)，H是树的高度,关于树的遍历，很可能Morris遍历的流程就是最优解

## 案例
对于二叉树如下：
Binary Tree:
=================================================
                                         v7v       
                        v6v       
                                         ^5^       
       H4H       
                                         v3v       
                        ^2^       
                                         ^1^    
=================================================
Morris序：cur依次到达每个节点的顺序
还是以上面二叉树为例
1.cur指向头节点4，节点4有左孩子，找到左孩子最右节点3，节点3的右孩子为null，则设置节点3的right为当前的cur也就是头节点4，cur向左移动跳到节点2
2.cur指向节点2，节点2有左孩子，找到左孩子最右节点1，节点1的右孩子为null，则设置节点1的right为当前的cur也就是头节点2，cur向左移动跳到节点1
3.cur指向节点1，节点1没有左孩子，cur向右移动回到节点2
4.cur指向节点2，当前节点有左孩子，找到左孩子最右节点1，此处需要注意：不要让节点1再访问到节点2，也就是节点1的right设置回null，cur向右移动到节点3
5.cur指向节点3，节点3没有左孩子，直接向右来到节点4
6.cur指向节点4，节点4有左孩子2，找到节点2的右边界3，右边界3的right=cur，设置右边界3的right为null，cur向右移动到节点6
7.cur指向节点6，节点6有左孩子5，找到5的右边界为null，设置右边界的right为节点6，cur向左移动来到节点5
8.cur指向节点5，节点5没有左孩子，直接向右来到节点6
9.cur指向节点6，节点6有左孩子5，找到节点5的右边界还是节点5，右边界5的right=cur，设置right=null,cur向右移动来到节点7
10.cur指向节点7，节点7没有左孩子，直接向右来到null，而cur == null 为终止条件
....
cur访问顺序4,2,1,2,3,4,6,5,6,7
任何节点只要有左孩子一定会来到两次,没有左孩子的会来到一次,4有左孩子，来到2次，2有左孩子，来到2次，6有左孩子，来到2次
每个节点都要走一遍左树的右边界

先序遍历：
递归序中：第一次来到一个节点的时候打印它，就是先序
Morris序中：能到达自己两次的第一次达到打印，不能到达自己两次的碰到就打印


4,2,1,2,3,4,6,5,6,7
√ √ √ × √ × √ √ × √ 

4,2,1,3,6,5,7

中序遍历：
递归序中：第二次来到一个节点的时候打印它，就是中序
Morris序中：
cur节点：
    无左树，直接打印，打印完往右移动
    有左树：
           1.第一次来到自己的时候，改完左树右边界往左移动
           2.第二次来到自己的时候，改完左树右边界，打印，往右移动
总结为：要往右移动了就打印

4,2,1,2,3,4,6,5,6,7
× × √ √ √ √ × √ √ √ 

1，2,3,4,5,6,7

只有一次到达它的节点，到达它就打印，第一次和第二次是合并的

后序遍历：
打印时机：能回到自己两次且第二次回到自己的时候
1.有左树：第二次来到它的时候，左树的右边界逆序打印
2.最后处理整棵树的右边界

## 应用
### 题目一：
给定一棵二叉树的头节点head
求以head为头的树中，最小深度是多少？

思路：
所有叶子节点才是产生高度的节点。
1.怎么知道cur的高度
2.怎么在cur是真正叶子节点的时候抓到最小高度

假设 cur=head，当前高度是1，在第一层level=1
1.if cur无左树, cur右移, level++得到下一步cur的高度
2.if cur有左树，可以知道cur是第一次来到自己，还是第二次来到自己
  如果是第一次来到自己，肯定是从parent往左走或往右走来到自己的
  如果是第二次来到自己，遍历的上一个节点是左树上的右边界，这时候你的高度=之前那个节点的高度-左树上最右节点的高度
    如果pre.left=cur 那么cur.height = pre.height++   _**如果左孩子的右边界是指向自己的，就去减高度，否则就高度++**_
    比如第二次来到节点a，那么肯定是从左树的右边界过来的，那么用左树的右边界的高度-左树到左树右边界的节点数=cur.height

第二次到达某个节点的时候，去看左树右边界是不是叶子节点，是就去更新minHeight，整棵树最右边界的高度是没有被发现的，所有流程跑完之后最后抓一下

### 题目二：
用Morris序判断是否是搜索二叉树BST

BST解题思路：
用中序遍历一遍，节点的值是递增的
那用Morris序遍历呢？在中序遍历时，将打印行为改成前一个值是否<当前值即可

```
private static boolean isBST(Node head) {
        if (head == null) {
            return true;
        }

        Node cur = head;
        Node mostRight = null;
        Integer pre = null;

        while (cur != null) {
            mostRight = cur.left;
            if (mostRight != null) {
                while (mostRight.right != null && mostRight.right != cur) {
                    mostRight = mostRight.right;
                }

                if (mostRight.right == null) {
                    mostRight.right = cur;
                    cur = cur.left;
                    continue;
                } else {
                    mostRight.right = null;
                }
            }
            if (pre != null && pre >= cur.value) {
                return false;
            }
            pre = cur.value;
            cur = cur.right;
        }
        return true;
    }
```

## 思考
什么样的题只能用二叉树的递归套路解？
如果你需要左树给你个答案，右树给你个答案，空间复杂度一定不是O(1)的，
因为左树上的答案得缓存着，等右树上的答案收集上来才能加工父节点的答案，就用二叉树的递归套路

什么样的题可以用Morris遍历来解呢？
当你的求解流程你发现并不需要右侧树的答案，这个答案是递推的，左树收集完答案用完之后就再也不需要了，信息可以传递，那就可以用Morris遍历改
比如搜索二叉树问题