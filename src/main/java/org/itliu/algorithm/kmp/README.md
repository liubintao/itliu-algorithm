## KMP算法
假设字符串str长度为N，字符串match长度为M，M <= N
想确定str中是否有某个子串是等于match的。
时间复杂度O(N)

## KMP算法核心
1）如何理解next数组
2）如何利用next数组加速匹配过程，优化时的两个实质！（私货解释）
   两个关键点：
   （1）j位置不用重新匹配(已经相等了)，从可能不等的位置X（原地不动）开始即可
   （2）之前不会有匹配的K（在i和j之间）开始字符串的可能性，否则与match中前缀和后缀最大匹配长度矛盾
   
   X停在这不动，Y位置跳到当前位置存储的指标的位置，这个原理的实质是什么？
   X前面一段=Match当前位置前面一段=Match开始一段   这每一段就是Y位置存储的指标的长度
   
   

next数组里存储每个位置的指标，怎么理解这个指标呢？ 
这个位置的指标与自己是没有关系的，是当前位置之前的字符串中前缀和后缀相等时的最长匹配长度

注意：取范围时不要取到整体，整体是肯定相等的，例：aaaaaab，那前缀和后缀的最长匹配长度为5
不管match是什么字符串，0位置的指标都是-1，表示这个概念压根就不存在，1位置的指标在不取得之前字符串整体的前提下，人为规定是0


## 应用一
给你两个字符串，判断一个字符串是不是另一个字符串的旋转词？
解：将两个字符串1拼在一起，如果字符串2是字符串1的旋转词，那肯定包含在里面
例：两个123456123456，不管字符串2是123456,234561,345612,456123,561234,612345中的哪一个，肯定包含在拼在一起的字符串1中

## 应用二
给定两棵二叉树的头节点head1和head2，想知道head1中是否有某个子树的结构和head2完全一样
解：中序遍历两棵树，分别放到数组里，同理判断

